x86 PC 为例



通用寄存器：8个，分别为EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI
标志寄存器：1个，EFLAGS
控制寄存器：5个，分别为CR0-CR4
调试寄存器：8个，分别为DR0-DR7
系统地址寄存器:4个，GDTR、IDTR、LDTR和TR
16位段寄存器：6个，分别为CS,DS,ES,FS,GS,SS
其他寄存器：EIP、TSC等



XS为段寄存器，+ I 一起组成 PC地址

如 CS:IP / DS:SI / ES:DI 等





# 电脑开机加载OS过程

## 启动BIOS

主板上固定有个ROM芯片，其中会在固定位置0xFFFF0保存BIOS程序

开机时CPU从默认位置寻址，找到BIOS启动



BIOS会检测键盘、内存、显示器、硬盘等

最后会将磁盘中的OS引导程序（在磁盘中的0磁道0扇区）读取到内存的0x7c00处

然后把PC也设置在0x7c00，准备执行OS引导程序

> 程序计数器PC是一个抽象概念。x86 PC 里的具体实现，是CPU里的俩寄存器CS:IP
>
> PC = CS << 4 + IP ，如 CS=0x7c0, IP=0x000, 最终PC=0x7c00



## 操作系统引导程序

引导程序 bootsect.s 是一段汇编代码

将setup.s对应的程序加载至内存，在屏幕上输出Loading System

```assembly
start:
		mov    ax,#BOOTSEG    ;0x07c0,启动代码所在位置放入ax　　
		mov    ds,ax          ;将启动代码与ds寄存器关联
		mov    ax,#INITSEG    ;启动代码要被复制到的目的地址
		mov    es,ax          ;将目的地址与es寄存器关联
		mov    cx,#256        ;循环控制字节,512字节
		sub    si,si          ;si清零,ds:si即0x07c00
		sub    di,di          ;di清零,es:di即0x90000
		rep                   ;循环直到cx==0
		movw                	;将ds:si复制到es:di，即将7c00开始的bootsect.s挪到90000
		jmpi    go,INITSEG		;跳转到go标志处
		

;由于启动代码复制到了新位置，需要更改相应寄存器的值
go:    
		mov    ax,cs            ;将当前的cs值赋值给各寄存器,方便接下来程序继续执行
    mov    ds,ax
    mov    es,ax
    mov    ss,ax            ;开始引入栈
    mov    sp,#0xFF00    ;栈空间的起始地址为0x9ff00

;开始加载setup块
load_setup:
    mov    dx,#0x0000    ;为后面进入中断处理传入相应信息    
    mov    cx,#0x0002        
    mov    bx,#0x0200        
    mov    ax,#0x0200+SETUPLEN    
    int    0x13            ;进入中断服务程序,将setup.s对应的程序加载至内存指定地址    
    jnc    ok_load_setup;cf标志寄存器为0就跳转至ok_load_setup块    
    mov    dx,#0x0000
    mov    ax,#0x0000    ;cf!=０则重新设置传入信息,进入中断    
    int    0x13
    j    load_setup

;取磁盘驱动器参数
ok_load_setup:
    mov    dl,#0x00
    mov    ax,#0x0800    ;磁盘参数    
    int    0x13
    mov    ch,#0x00
    seg cs                ;下一条语句的操作数在cs所指段中
    mov    sectors,cx    ;保存每磁道扇区数
    mov    ax,#INITSEG
    mov    es,ax

;由于加载代码量庞大，这时在屏幕上输出 "Loding system..."
    mov    ah,#0x03         ;读光标位置
    xor    bh,bh
    int    0x10
    
    mov    cx,#24            ;共24个字符
    mov    bx,#0x0007    ;! page 0, attribute 7 (normal)
    mov    bp,#msg1        ;指向要显示字符串的地址
    mov    ax,#0x1301    ;! write string, move cursor
    int    0x10

;加载第三批代码，即剩余内核代码，时间较长
    mov    ax,#SYSSEG    ;内核代码被加载到的地址
    mov    es,ax            ;! segment of 0x010000
    call    read_it    ;读取磁盘上的system模块
    call    kill_motor;关闭驱动器

;确定使用哪个根文件系统设备,若指定了设备(开始的ax!=0)，就直接用给定的设备
    seg cs
    mov    ax,root_dev
    cmp    ax,#0            ;比较ax是否为0
    jne    root_defined    ;ax!=0跳转
    seg cs
    mov    bx,sectors    ;取磁道扇区数，如果sectors==15,则说明是1.2Mb驱动器
                        ;如果sectors==18,则说明是1.44Mb驱动器
    mov    ax,#0x0208    ;! /dev/ps0 - 1.2Mb
    cmp    bx,#15            ;判断磁道扇区数是否为15
    je    root_defined
    mov    ax,#0x021c    ;! /dev/PS0 - 1.44Mb
    cmp    bx,#18
    je    root_defined
undef_root:            ;如果都不是，死循环
    jmp undef_root
root_defined:
    seg cs
    mov    root_dev,ax    ;保存设备号到数据区

;本程序执行完毕，跳转到已经加载在内存的setup处继续执行
    jmpi    0,SETUPSEG

;以下是被调用的块的详细代码,以及显示在屏幕的文字信息的数据安排
sread:    .word 1+SETUPLEN    ! sectors read of current track
head:    .word 0            ! current head
track:    .word 0            ! current track

read_it:
    mov ax,es
    test ax,#0x0fff
die:    jne die            ! es must be at 64kB boundary
    xor bx,bx        ! bx is starting address within segment
rp_read:
    mov ax,es
    cmp ax,#ENDSEG        ! have we loaded all yet?
    jb ok1_read
    ret
ok1_read:
    seg cs
    mov ax,sectors
    sub ax,sread
    mov cx,ax
    shl cx,#9
    add cx,bx
    jnc ok2_read
    je ok2_read
    xor ax,ax
    sub ax,bx
    shr ax,#9
ok2_read:
    call read_track
    mov cx,ax
    add ax,sread
    seg cs
    cmp ax,sectors
    jne ok3_read
    mov ax,#1
    sub ax,head
    jne ok4_read
    inc track
ok4_read:
    mov head,ax
    xor ax,ax
ok3_read:
    mov sread,ax
    shl cx,#9
    add bx,cx
    jnc rp_read
    mov ax,es
    add ax,#0x1000
    mov es,ax
    xor bx,bx
    jmp rp_read

read_track:
    push ax
    push bx
    push cx
    push dx
    mov dx,track
    mov cx,sread
    inc cx
    mov ch,dl
    mov dx,head
    mov dh,dl
    mov dl,#0
    and dx,#0x0100
    mov ah,#2
    int 0x13
    jc bad_rt
    pop dx
    pop cx
    pop bx
    pop ax
    ret
bad_rt:    mov ax,#0
    mov dx,#0
    int 0x13
    pop dx
    pop cx
    pop bx
    pop ax
    jmp read_track

!/*
! * This procedure turns off the floppy drive motor, so
! * that we enter the kernel in a known state, and
! * don't have to worry about it later.
! */
kill_motor:
    push dx
    mov dx,#0x3f2
    mov al,#0
    outb
    pop dx
    ret

sectors:
    .word 0

msg1:
    .byte 13,10
    .ascii "Loading system ..."
    .byte 13,10,13,10

.org 508
root_dev:
    .word ROOT_DEV
boot_flag:
    .word 0xAA55

.text
endtext:
.data
enddata:
.bss
endbss:
```



## Setup

setup.s 初始化操作系统

读取内存大小，读取操作系统程序到内存0起始位置（之前的bootsect已经被挪走）

最后进入保护程序，切换到32位模式（之前cs:ip是16位<<4位+16位=16位）















