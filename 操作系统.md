x86 PC 为例



通用寄存器：8个，分别为EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI
标志寄存器：1个，EFLAGS
控制寄存器：5个，分别为CR0-CR4
调试寄存器：8个，分别为DR0-DR7
系统地址寄存器:4个，GDTR、IDTR、LDTR和TR
16位段寄存器：6个，分别为CS,DS,ES,FS,GS,SS
其他寄存器：EIP、TSC等



XS为段寄存器，+ I 一起组成 PC地址

如 CS:IP / DS:SI / ES:DI 等



# 操作系统历史

1. 手工输入输出
2. 打孔带、磁带等自动化输入输出
3. 批处理流水线自动化输入输出 IBSYS

4. 多进程结构（改善 某个任务IO时阻塞，浪费CPU）OS/360
5. 分时系统（改进，可以多人使用）MULTICS
6. 改进 UNIX、Linux
7. 图形界面、文件系统 System、Mac





# 电脑开机加载OS过程

<img src="/Users/lcy/Documents/note/操作系统.assets/image-20211025110954520.png" alt="image-20211025110954520" style="zoom:70%;" />



## 启动BIOS

主板上固定有个ROM芯片，其中会在固定位置0xFFFF0保存BIOS程序

开机时CPU从默认位置寻址，找到BIOS启动



BIOS会检测键盘、内存、显示器、硬盘等

最后会将磁盘中的OS引导程序bootloader（在磁盘中的0磁道0扇区）读取到内存的0x7c00处

然后把PC也设置在0x7c00，准备执行OS引导程序

> 程序计数器PC是一个抽象概念。x86 PC 里的具体实现，是CPU里的俩寄存器CS:IP
>
> PC = CS << 4 + IP ，如 CS=0x7c0, IP=0x000, 最终PC=0x7c00



## Bootsect

操作系统引导程序 bootsect.s 是一段汇编代码

将setup.s对应的程序加载至内存，在屏幕上输出Loading System

```assembly
start:
		mov    ax,#BOOTSEG    ;0x07c0,启动代码所在位置放入ax　　
		mov    ds,ax          ;将启动代码与ds寄存器关联
		mov    ax,#INITSEG    ;启动代码要被复制到的目的地址
		mov    es,ax          ;将目的地址与es寄存器关联
		mov    cx,#256        ;循环控制字节,512字节
		sub    si,si          ;si清零,ds:si即0x07c00
		sub    di,di          ;di清零,es:di即0x90000
		rep                   ;循环直到cx==0
		movw                	;将ds:si复制到es:di，即将7c00开始的bootsect.s挪到90000
		jmpi    go,INITSEG		;跳转到go标志处
		

;由于启动代码复制到了新位置，需要更改相应寄存器的值
go:    
		mov    ax,cs            ;将当前的cs值赋值给各寄存器,方便接下来程序继续执行
    mov    ds,ax
    mov    es,ax
    mov    ss,ax            ;开始引入栈
    mov    sp,#0xFF00    ;栈空间的起始地址为0x9ff00

;开始加载setup块
load_setup:
    mov    dx,#0x0000    ;为后面进入中断处理传入相应信息    
    mov    cx,#0x0002        
    mov    bx,#0x0200        
    mov    ax,#0x0200+SETUPLEN    
    int    0x13            ;进入中断服务程序,将setup.s对应的程序加载至内存指定地址    
    jnc    ok_load_setup;cf标志寄存器为0就跳转至ok_load_setup块    
    mov    dx,#0x0000
    mov    ax,#0x0000    ;cf!=０则重新设置传入信息,进入中断    
    int    0x13
    j    load_setup

;取磁盘驱动器参数
ok_load_setup:
    mov    dl,#0x00
    mov    ax,#0x0800    ;磁盘参数    
    int    0x13
    mov    ch,#0x00
    seg cs                ;下一条语句的操作数在cs所指段中
    mov    sectors,cx    ;保存每磁道扇区数
    mov    ax,#INITSEG
    mov    es,ax

;由于加载代码量庞大，这时在屏幕上输出 "Loding system..."
    mov    ah,#0x03         ;读光标位置
    xor    bh,bh
    int    0x10
    
    mov    cx,#24            ;共24个字符
    mov    bx,#0x0007    ;! page 0, attribute 7 (normal)
    mov    bp,#msg1        ;指向要显示字符串的地址
    mov    ax,#0x1301    ;! write string, move cursor
    int    0x10

...

;本程序执行完毕，跳转到已经加载在内存的setup处继续执行
    jmpi    0,SETUPSEG
```



## Setup

setup.s 初始化操作系统

读取内存大小，读取操作系统程序到内存0起始位置（之前的bootsect已经被挪走）

最后进入保护程序，切换到32位模式（之前cs:ip是16位<<4位+16位=16位）



# 操作系统接口

操作系统将重要的功能封装成函数，提供给应用软件调用。这些系统函数就是接口，使用的时候叫「系统调用」。



## 系统调用命令

命令标准手册

Win32 API 用于 Windows

POSIX API 用于Unix Linux等

```sh
# 创建进程
fork

# 打开文件/夹
open

...

```



## 系统调用的实现

### 用户不能直接调用内核

系统函数在内存中，应用也在内存中，不能直接跳过系统调用直接使用内核中的函数或数据吗？



Why？

不行，不安全。



How？

硬件设计，直接将内核程序和用户程序隔离。

用CS表示不同态，0是内核态，3是用户态。则CS:IP调用指令时，就可以判断DPL>=CPL进行隔离了。



### 用户如何使用内核

对于 Intel x86，使用中断指令int 0x80（唯一大门）



# 内存

<img src="/Users/lcy/Documents/note/操作系统.assets/image-20211025141859760.png" alt="image-20211025141859760" style="zoom:70%;" />



## 做什么

操作系统会将「物理内存」进一步封装成「虚拟内存」

主要为了：

抽象。可以使用连续的逻辑地址。

保护。应用间地址不干扰。

共享。访问相同物理内存。

虚拟化。借助磁盘虚拟出更多的地址空间。



## 怎么做

管理内存的方法：

程序重定位

分段

分页

虚拟内存

按需分页虚拟内存



### 连续内存分配

程序需要分配连续地址的内存，当关闭时还会回收，因此大小不同的内存需求会产生碎片

如何更好利用碎片空间？

匹配：

* 第一适配。从前到后寻找第一个空间足够的碎片。简单。
* 最优适配。找到碎片大小足够，且新产生空间最小的碎片。适合大部分都是小尺寸的，但效率慢。
* 最差适配。找到新产生空间最大的碎片使用。适合大部分是中尺寸的，但效率慢。

整理：

* 压缩式。空余期间，把程序紧挨着挪到一头，腾出更大空余空间。
* 交换式。正在运行的程序需要更大内存，且整个内存不足时，把非运行的程序挪到硬盘，腾给当前程序。



### 非连续内存分配

程序使用虚拟内存，是连续的，映射的物理内存可以是不连续的。

物理连续内存有碎片，利用率低。非连续内存空间虽然有一定开销，但利用率更高。

可以使用软件、硬件实现非连续内存分配，硬件效率更好，具体方案有：分段、分页

#### 分段

x86 CPU取地址时，使用的是段寄存器+偏移量寄存器，俩值拼在一起组成目标物理地址。

这就是一种分段的硬件实现。CPU里维护一份段表 ？？？

#### 分页（主流）

类似分段，每页大小不变，但每段大小可变。

虚拟内存中分页，地址 = 页号p + 偏移量o

物理内存也分页，地址 = 帧号f + 偏移量o

使用的时候虚拟内存用页号p，去页表中查对应的f，然后+偏移量o得到虚拟地址对应的物理地址。

#### 页表

<img src="/Users/lcy/Documents/note/操作系统.assets/image-20211104170819475.png" alt="image-20211104170819475" style="zoom:50%;" />

虚拟内存一般>物理内存，所以可能出现不匹配的情况，会用到虚拟内存。

页表除了物理内存地址，前面还有几个标志位，如第二位就是对应物理内存是否真实存在。



##### 问题

时间效率低。二次查询执行。

空间效率低。页表占空间大。



##### 如何解决？

时间效率低：TLB

缓存近期访问的页帧转换表项 Translation Look-aside Buffer

CPU的MMU内存管理单元里有个TLB，用于缓存常用页表，CPU在里面直接找，找不到时再去内存的页表找



空间效率低：二/多级页表

时间换空间。

多一层页表，指数降低空间大小。且虚拟对应的物理不存在时，不需要二级页表。



空间效率低：反向页表

页表不和逻辑地址挂钩（大），和物理地址挂钩（小）



### 虚拟内存

程序对内存的需求增长 > 内存硬件的增长

以下技术都是为了在小内存里运行大程序。



#### 覆盖技术

程序拆分，必要的部分放在内存里，非必要的按需覆盖到内存里，或挪出到硬盘里。

时间换空间。增加编程复杂度。

处理单个大程序。由应用自己实现。



#### 交换技术

将暂时不能运行的程序送到外存swap out，将外层里某个进程地址空间读入内存swap in。

换入换出内容的大小为整个程序的地址空间。

处理多程序。由交互系统完成。



问题：

什么时候交换？内存不够时换。

交换区多大？足够大以存放所有用户进程的内存。

换入时地址变了怎么办？最好采用动态地址映射法，页表。



#### 虚存技术

综上

大体流程是：装入程序时，只加载部分必要部分到内存。执行过程中，如果碰到需要的把硬盘里的加入内存，不需要的放到硬盘。

具体技术上：加载部分使用到交换技术，但这里粒度更小，使用分页技术。到分页级别意味着是非连续的内存分配，这里可以用页表解决。



流程细节：

1. 程序先加载必要部分到内存
2. CPU的MMU为这部分建立页表
3. 程序执行到不存在于内存的部分时，CPU查询页表发现虚拟内存地址对应的物理地址不存在，抛出异常
4. 操作系数接收到异常，再去外存中找到这部分，交换技术将其调入内存。同理换出不常用的部分。





# 多进程

内存、CPU





# 文件

IO、Disk



