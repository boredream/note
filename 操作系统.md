x86 PC 为例



通用寄存器：8个，分别为EAX,EBX,ECX,EDX,ESP,EBP,ESI,EDI
标志寄存器：1个，EFLAGS
控制寄存器：5个，分别为CR0-CR4
调试寄存器：8个，分别为DR0-DR7
系统地址寄存器:4个，GDTR、IDTR、LDTR和TR
16位段寄存器：6个，分别为CS,DS,ES,FS,GS,SS
其他寄存器：EIP、TSC等



XS为段寄存器，+ I 一起组成 PC地址

如 CS:IP / DS:SI / ES:DI 等



# 操作系统历史

1. 手工输入输出
2. 打孔带、磁带等自动化输入输出
3. 批处理流水线自动化输入输出 IBSYS

4. 多进程结构（改善 某个任务IO时阻塞，浪费CPU）OS/360
5. 分时系统（改进，可以多人使用）MULTICS
6. 改进 UNIX、Linux
7. 图形界面、文件系统 System、Mac





# 电脑开机加载OS过程

<img src="/Users/lcy/Documents/note/操作系统.assets/image-20211025110954520.png" alt="image-20211025110954520" style="zoom:70%;" />



## 启动BIOS

主板上固定有个ROM芯片，其中会在固定位置0xFFFF0保存BIOS程序

开机时CPU从默认位置寻址，找到BIOS启动



BIOS会检测键盘、内存、显示器、硬盘等

最后会将磁盘中的OS引导程序bootloader（在磁盘中的0磁道0扇区）读取到内存的0x7c00处

然后把PC也设置在0x7c00，准备执行OS引导程序

> 程序计数器PC是一个抽象概念。x86 PC 里的具体实现，是CPU里的俩寄存器CS:IP
>
> PC = CS << 4 + IP ，如 CS=0x7c0, IP=0x000, 最终PC=0x7c00



## Bootsect

操作系统引导程序 bootsect.s 是一段汇编代码

将setup.s对应的程序加载至内存，在屏幕上输出Loading System

```assembly
start:
		mov    ax,#BOOTSEG    ;0x07c0,启动代码所在位置放入ax　　
		mov    ds,ax          ;将启动代码与ds寄存器关联
		mov    ax,#INITSEG    ;启动代码要被复制到的目的地址
		mov    es,ax          ;将目的地址与es寄存器关联
		mov    cx,#256        ;循环控制字节,512字节
		sub    si,si          ;si清零,ds:si即0x07c00
		sub    di,di          ;di清零,es:di即0x90000
		rep                   ;循环直到cx==0
		movw                	;将ds:si复制到es:di，即将7c00开始的bootsect.s挪到90000
		jmpi    go,INITSEG		;跳转到go标志处
		

;由于启动代码复制到了新位置，需要更改相应寄存器的值
go:    
		mov    ax,cs            ;将当前的cs值赋值给各寄存器,方便接下来程序继续执行
    mov    ds,ax
    mov    es,ax
    mov    ss,ax            ;开始引入栈
    mov    sp,#0xFF00    ;栈空间的起始地址为0x9ff00

;开始加载setup块
load_setup:
    mov    dx,#0x0000    ;为后面进入中断处理传入相应信息    
    mov    cx,#0x0002        
    mov    bx,#0x0200        
    mov    ax,#0x0200+SETUPLEN    
    int    0x13            ;进入中断服务程序,将setup.s对应的程序加载至内存指定地址    
    jnc    ok_load_setup;cf标志寄存器为0就跳转至ok_load_setup块    
    mov    dx,#0x0000
    mov    ax,#0x0000    ;cf!=０则重新设置传入信息,进入中断    
    int    0x13
    j    load_setup

;取磁盘驱动器参数
ok_load_setup:
    mov    dl,#0x00
    mov    ax,#0x0800    ;磁盘参数    
    int    0x13
    mov    ch,#0x00
    seg cs                ;下一条语句的操作数在cs所指段中
    mov    sectors,cx    ;保存每磁道扇区数
    mov    ax,#INITSEG
    mov    es,ax

;由于加载代码量庞大，这时在屏幕上输出 "Loding system..."
    mov    ah,#0x03         ;读光标位置
    xor    bh,bh
    int    0x10
    
    mov    cx,#24            ;共24个字符
    mov    bx,#0x0007    ;! page 0, attribute 7 (normal)
    mov    bp,#msg1        ;指向要显示字符串的地址
    mov    ax,#0x1301    ;! write string, move cursor
    int    0x10

...

;本程序执行完毕，跳转到已经加载在内存的setup处继续执行
    jmpi    0,SETUPSEG
```



## Setup

setup.s 初始化操作系统

读取内存大小，读取操作系统程序到内存0起始位置（之前的bootsect已经被挪走）

最后进入保护程序，切换到32位模式（之前cs:ip是16位<<4位+16位=16位）



# 操作系统接口

操作系统将重要的功能封装成函数，提供给应用软件调用。这些系统函数就是接口，使用的时候叫「系统调用」。



## 系统调用命令

POSIX 命令标准手册

```sh
# 创建进程
fork

# 打开文件/夹
open

...

```



## 系统调用的实现

### 用户不能直接调用内核

系统函数在内存中，应用也在内存中，不能直接跳过系统调用直接使用内核中的函数或数据吗？



Why？

不行，不安全。



How？

硬件设计，直接将内核程序和用户程序隔离。

用CS表示不同态，0是内核态，3是用户态。则CS:IP调用指令时，就可以判断DPL>=CPL进行隔离了。



### 用户如何使用内核

对于 Intel x86，使用中断指令int 0x80（唯一大门）



# 内存

<img src="/Users/lcy/Documents/note/操作系统.assets/image-20211025141859760.png" alt="image-20211025141859760" style="zoom:70%;" />





# 多进程

内存、CPU





# 文件

IO、Disk



