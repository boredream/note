

# 方案选择

## 方案一【废弃】

直接针对单个业务类型数据设计：

如轨迹，本地每笔数据记录dbId + id，前者是本地id，后者是上传到服务端后的数据。

这样的话本地可以及时+轮询判断，如果某个数据没有id，代表没上传到服务器，则上传后更新本地id。

问题：

如何知道服务端有数据是本地没有的呢？全量拉取服务端数据本地挨个判断不可取。



---



## 方案二

设计总的同步信息对象：

类似于版本更新，本地数据有个总的更新时间or版本，服务端也有。每次应用启动后尝试检查更新。



# 技术选型









# 方案细节



## 同步场景

### 一、用户保存

1. 本地保存单笔业务数据，记录是否要同步标志位
2. 将保存的数据同步到服务端，服务端收到数据后，插入数据库生成id+时间戳，同时记录全局时间戳信息
3. 服务端返回id+时间戳，本地更新到单笔业务数据里，清除同步标志位，同时记录全局时间戳信息

> 本地数据 - 创建：
>
> dbId: xxx
>
> id: null
>
> synced = false



> 本地数据 - 提交远程后：
>
> dbId: xxx
>
> id: xxx
>
> synced = true



### 二、用户保存失败，再次上传

1. 本地保存单笔业务数据，记录是否要同步标志位
2. 将保存的数据同步到服务端，断网失败了
3. 再次检测上传的时候，扫描本地同步标志位，再进行上传
4. 上传成功后和【一】后续处理一致



### 三、用户修改

和保存同理，区别在于不用更新服务端id，只更新时间戳和标志位



### 四、拉取数据

1. App启动、用户主动发起等情况下触发
2. 本地的时间戳来源于每次提交服务器数据返回的时间，所以前后端时间戳的规则是一致的
3. 把本地全局时间戳发给服务端，服务端判断时间戳是否一样，如果本地时间戳<服务端时间戳，则需要更新
4. 服务端把本地时间戳之后的所有数据都查询出来，一次性返回给前端 【但只能针对一种数据？？】
5. 拉取的数据先和本地进行比较，id不存在的新数据直接插入，如果是id存在的继续判断
6. 如果本地待更新的这笔数据，同步标志位是false，直接以服务端为准，覆盖即可
7. 如果本地待更新的这笔数据，同步标志位是true，即本地有修改还没提交给服务端的，进入到冲突处理
8. 冲突数据【保留本地的】，因为大部分是珍贵的轨迹收集数据，所以本地为准，服务端数据抛弃



### 五、同步数据

一般很少单独只拉取，拉取完成后会继续check本地是否有数据要提交。

先拉取，处理冲突，再提交。



